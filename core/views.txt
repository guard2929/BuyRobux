import re
import requests
from django.shortcuts import render, redirect
from django.contrib.auth import login, logout
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import require_POST
from django.http import JsonResponse
from django.conf import settings
from django.utils import timezone
from web3 import Web3
import qrcode
from io import BytesIO
from base64 import b64encode
from .models import CustomUser, Purchase, Withdrawal
from .forms import LoginForm

def generate_payment_address():
    account = Web3().eth.account.create()
    return account.address

def generate_qr_code(address, amount, currency='ETH'):
    qr_data = f"{currency.lower()}:{address}?amount={amount}"
    qr = qrcode.QRCode(version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=4)
    qr.add_data(qr_data)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white")
    buffer = BytesIO()
    img.save(buffer, format="PNG")
    return b64encode(buffer.getvalue()).decode('utf-8')

@login_required
@require_POST
def buy_robux_crypto(request):
    robux_steps = int(request.POST.get('robux_steps', 0))
    robux_amount = 20 + (robux_steps * 20)
    price_rub = robux_amount * 0.76 * settings.RUB_EXCHANGE_RATE
    promo_code = request.POST.get('promo_code', '')

    if robux_amount < 20 or robux_amount > 5000:
        return render(request, 'core/index.html', {'error': 'Неверное количество Robux.'})

    if promo_code:
        try:
            friend = CustomUser.objects.get(promo_code=promo_code)
            if friend == request.user:
                return render(request, 'core/index.html', {'error': 'Нельзя использовать свой промокод.'})
        except CustomUser.DoesNotExist:
            return render(request, 'core/index.html', {'error': 'Неверный промокод.'})

    crypto_amount = price_rub / settings.RUB_EXCHANGE_RATE
    payment_address = generate_payment_address()

    purchase = Purchase.objects.create(
        user=request.user,
        robux_amount=robux_amount,
        price=price_rub,
        status='pending',
        promo_code_used=promo_code,
        crypto_address=payment_address,
        crypto_amount=crypto_amount
    )

    qr_code = generate_qr_code(payment_address, crypto_amount, settings.PAYMENT_CURRENCY)

    context = {
        'robux': robux_amount,
        'price': round(price_rub, 2),
        'crypto_amount': crypto_amount,
        'payment_address': payment_address,
        'qr_code': qr_code,
        'purchase_id': purchase.id,
        'promo_code': promo_code,
    }
    return render(request, 'core/crypto_payment.html', context)


@login_required
@require_POST
def buy_robux_crypto(request):
    robux_steps = int(request.POST.get('robux_steps', 0))
    robux_amount = 20 + (robux_steps * 20)
    price_rub = robux_amount * 0.76 * settings.RUB_EXCHANGE_RATE
    promo_code = request.POST.get('promo_code', '')

    if robux_amount < 20 or robux_amount > 5000:
        return render(request, 'core/index.html', {'error': 'Неверное количество Robux.'})

    if promo_code:
        try:
            friend = CustomUser.objects.get(promo_code=promo_code)
            if friend == request.user:
                return render(request, 'core/index.html', {'error': 'Нельзя использовать свой промокод.'})
        except CustomUser.DoesNotExist:
            return render(request, 'core/index.html', {'error': 'Неверный промокод.'})

    # Рассчитываем сумму в криптовалюте
    crypto_amount = price_rub / settings.RUB_EXCHANGE_RATE  # Предполагаем, что RUB_EXCHANGE_RATE учитывает курс ETH

    # Генерируем адрес для оплаты
    payment_address = generate_payment_address()

    # Создаем запись о покупке
    purchase = Purchase.objects.create(
        user=request.user,
        robux_amount=robux_amount,
        price=price_rub,
        status='pending',
        promo_code_used=promo_code,
        crypto_address=payment_address,
        crypto_amount=crypto_amount
    )

    # Генерируем QR-код
    qr_code = generate_qr_code(payment_address, crypto_amount, settings.PAYMENT_CURRENCY)

    context = {
        'robux': robux_amount,
        'price': round(price_rub, 2),
        'crypto_amount': crypto_amount,
        'payment_address': payment_address,
        'qr_code': qr_code,
        'purchase_id': purchase.id,
        'promo_code': promo_code,
    }
    return render(request, 'core/crypto_payment.html', context)


# Существующие представления остаются без изменений
def index(request):
    context = {}
    recent_purchases = Purchase.objects.select_related('user').order_by('-created_at')[:3]
    context['recent_purchases'] = recent_purchases
    if request.user.is_authenticated:
        purchases = Purchase.objects.filter(user=request.user).order_by('-created_at')
        context['purchases'] = purchases
        context['user_promo_code'] = request.user.promo_code
        context['bonus_balance'] = request.user.bonus_balance
        context['is_first_purchase'] = not purchases.exists()
    return render(request, 'core/index.html', context)


@login_required
@require_POST
def buy_robux_step2(request):
    robux_steps = int(request.POST.get('robux_steps', 0))
    robux_amount = 20 + (robux_steps * 20)
    price_rub = robux_amount * 0.76 * settings.RUB_EXCHANGE_RATE
    promo_code = request.POST.get('promo_code', '')

    if robux_amount < 20 or robux_amount > 5000:
        return render(request, 'core/index.html', {'error': 'Неверное количество Robux.'})

    if promo_code:
        try:
            friend = CustomUser.objects.get(promo_code=promo_code)
            if friend == request.user:
                return render(request, 'core/index.html', {'error': 'Нельзя использовать свой промокод.'})
        except CustomUser.DoesNotExist:
            return render(request, 'core/index.html', {'error': 'Неверный промокод.'})

    places = get_roblox_places(request.user.roblox_nick)
    if not places:
        return render(request, 'core/step2.html', {
            'error': 'У вас нет доступных мест в Roblox.',
            'robux': robux_amount,
            'price': round(price_rub, 2),
            'promo_code': promo_code,
        })
    context = {
        'robux': robux_amount,
        'price': round(price_rub, 2),
        'places': places,
        'promo_code': promo_code,
    }
    return render(request, 'core/step2.html', context)


@login_required
@require_POST
def buy_robux_step3(request):
    robux_amount = int(request.POST.get('robux', 0))
    price = float(request.POST.get('price', 0))
    place_id = request.POST.get('place_id')
    place_name = request.POST.get('place_name', '')
    promo_code = request.POST.get('promo_code', '')
    place_link = request.POST.get('place_link', '')
    action = request.POST.get('action')
    selected_gamepass_id = request.POST.get('gamepass_id')

    if not place_id:
        return render(request, 'core/step2.html', {
            'error': 'Пожалуйста, выберите место.',
            'robux': robux_amount,
            'price': price,
            'places': get_roblox_places(request.user.roblox_nick),
            'promo_code': promo_code,
        })

    purchase = Purchase.objects.create(
        user=request.user,
        robux_amount=robux_amount,
        price=price,
        place_id=place_id,
        place_name=place_name,
        status='pending',
        promo_code_used=promo_code
    )

    universe_id = get_universe_id(place_id)
    if not universe_id:
        return render(request, 'core/step3.html', {
            'error': 'Не удалось получить universe_id.',
            'robux': robux_amount,
            'price': price,
            'place_id': place_id,
            'place_name': place_name,
            'purchase_id': purchase.id,
            'promo_code': promo_code,
            'place_link': place_link,
        })

    gamepasses = get_gamepasses(universe_id)
    if not gamepasses:
        return render(request, 'core/step3.html', {
            'error': 'Нет доступных GamePass для этого места.',
            'robux': robux_amount,
            'price': price,
            'place_id': place_id,
            'place_name': place_name,
            'purchase_id': purchase.id,
            'promo_code': promo_code,
            'place_link': place_link,
        })

    if action == 'check' and selected_gamepass_id:
        matching_gamepass = next((gp for gp in gamepasses if str(gp['id']) == selected_gamepass_id), None)
        if not matching_gamepass:
            return render(request, 'core/step3.html', {
                'error': 'Указанный GamePass не найден.',
                'robux': robux_amount,
                'price': price,
                'place_id': place_id,
                'place_name': place_name,
                'purchase_id': purchase.id,
                'promo_code': promo_code,
                'place_link': place_link,
                'universe_id': universe_id,
                'gamepasses': gamepasses,
                'instruction': (
                    "1. Выберите существующий GamePass или создайте новый с ценой {} Robux.\n"
                    "2. Опубликуйте и активируйте 'For Sale'.\n"
                    "3. Завершите процесс покупки.".format(robux_amount)
                ),
            })

        expected_price = robux_amount
        if matching_gamepass['price'] != expected_price:
            return render(request, 'core/step3.html', {
                'error': f'Цена GamePass ({matching_gamepass["price"]} Robux) не соответствует запрошенному количеству ({expected_price} Robux).',
                'robux': robux_amount,
                'price': price,
                'place_id': place_id,
                'place_name': place_name,
                'purchase_id': purchase.id,
                'promo_code': promo_code,
                'place_link': place_link,
                'universe_id': universe_id,
                'gamepasses': gamepasses,
                'instruction': (
                    "1. Выберите существующий GamePass или создайте новый с ценой {} Robux.\n"
                    "2. Опубликуйте и активируйте 'For Sale'.\n"
                    "3. Завершите процесс покупки.".format(robux_amount)
                ),
            })

        try:
            gamepass_detail = requests.get(
                f"https://api.roblox.com/marketplace/game-pass-product-info?gamePassId={selected_gamepass_id}",
                headers={'x-api-key': settings.ROBLOX_API_KEY},
                timeout=5
            ).json()
            if not gamepass_detail.get('IsForSale', False):
                return render(request, 'core/step3.html', {
                    'error': 'GamePass не активен для продажи.',
                    'robux': robux_amount,
                    'price': price,
                    'place_id': place_id,
                    'place_name': place_name,
                    'purchase_id': purchase.id,
                    'promo_code': promo_code,
                    'place_link': place_link,
                    'universe_id': universe_id,
                    'gamepasses': gamepasses,
                    'instruction': (
                        "1. Активируйте 'For Sale' для GamePass с ценой {} Robux.\n"
                        "2. Нажмите 'Проверить' снова.".format(robux_amount)
                    ),
                })
        except Exception:
            pass

    elif action == 'check' and not selected_gamepass_id:
        return render(request, 'core/step3.html', {
            'error': 'Выберите существующий GamePass или создайте новый.',
            'robux': robux_amount,
            'price': price,
            'place_id': place_id,
            'place_name': place_name,
            'purchase_id': purchase.id,
            'promo_code': promo_code,
            'place_link': place_link,
            'universe_id': universe_id,
            'gamepasses': gamepasses,
            'instruction': (
                "1. Выберите существующий GamePass или создайте новый с ценой {} Robux.\n"
                "2. Опубликуйте и активируйте 'For Sale'.\n"
                "3. Завершите процесс покупки.".format(robux_amount)
            ),
        })

    context = {
        'robux': robux_amount,
        'price': price,
        'place_id': place_id,
        'place_name': place_name,
        'purchase_id': purchase.id,
        'promo_code': promo_code,
        'place_link': place_link,
        'universe_id': universe_id,
        'gamepasses': gamepasses,
        'instruction': (
            "1. Выберите существующий GamePass или создайте новый с ценой {} Robux.\n"
            "2. Опубликуйте и активируйте 'For Sale'.\n"
            "3. Завершите процесс покупки.".format(robux_amount)
        ),
    }
    return render(request, 'core/step3.html', context)


@login_required
def withdraw_bonus(request):
    if request.user.bonus_balance < 50:
        return render(request, 'core/withdraw.html', {'error': 'Недостаточно средств для вывода.'})
    if request.method == 'POST':
        return redirect('core:withdraw_step2')
    return render(request, 'core/withdraw.html', {'bonus_balance': request.user.bonus_balance})


@login_required
def withdraw_step2(request):
    if request.user.bonus_balance < 50:
        return render(request, 'core/withdraw.html', {'error': 'Недостаточно средств для вывода.'})
    places = get_roblox_places(request.user.roblox_nick)
    if not places:
        return render(request, 'core/withdraw_step2.html',
                      {'error': 'У вас нет доступных мест.', 'bonus_balance': request.user.bonus_balance})
    return render(request, 'core/withdraw_step2.html', {'places': places, 'bonus_balance': request.user.bonus_balance})


@login_required
@require_POST
def withdraw_step3(request):
    bonus_balance = float(request.POST.get('bonus_balance', 0))
    place_id = request.POST.get('place_id')
    place_link = request.POST.get('place_link', '')
    action = request.POST.get('action')
    selected_gamepass_id = request.POST.get('gamepass_id')

    if not place_id:
        return render(request, 'core/withdraw_step2.html', {
            'error': 'Пожалуйста, выберите место.',
            'places': get_roblox_places(request.user.roblox_nick),
            'bonus_balance': bonus_balance
        })

    universe_id = get_universe_id(place_id)
    if not universe_id:
        return render(request, 'core/withdraw_step3.html', {
            'error': 'Не удалось получить universe_id для выбранного места.',
            'bonus_balance': bonus_balance,
            'place_id': place_id
        })

    gamepasses = get_gamepasses(universe_id)
    requested_price = round(bonus_balance / 0.7)
    if action == 'check' and not selected_gamepass_id and gamepasses:
        return render(request, 'core/withdraw_step3.html', {
            'error': 'Выберите существующий GamePass или создайте новый.',
            'bonus_balance': bonus_balance,
            'place_id': place_id,
            'place_link': place_link,
            'gamepasses': gamepasses,
            'requested_price': requested_price,
            'instruction': (
                "1. Выберите существующий GamePass или создайте новый с ценой {} Robux.\n"
                "2. Опубликуйте и активируйте 'For Sale'.\n"
                "3. Нажмите 'Проверить', затем 'Подтвердить'.".format(requested_price)
            ),
        })

    if action == 'check' and selected_gamepass_id:
        matching_gamepass = next((gp for gp in gamepasses if str(gp['id']) == selected_gamepass_id), None)
        if not matching_gamepass or matching_gamepass['price'] != requested_price:
            return render(request, 'core/withdraw_step3.html', {
                'error': f'Выбранный GamePass должен стоить {requested_price} Robux.',
                'bonus_balance': bonus_balance,
                'place_id': place_id,
                'place_link': place_link,
                'gamepasses': gamepasses,
                'requested_price': requested_price,
                'instruction': (
                    "1. Выберите существующий GamePass или создайте новый с ценой {} Robux.\n"
                    "2. Опубликуйте и активируйте 'For Sale'.\n"
                    "3. Нажмите 'Проверить', затем 'Подтвердить'.".format(requested_price)
                ),
            })

    context = {
        'bonus_balance': bonus_balance,
        'place_id': place_id,
        'place_link': place_link,
        'gamepasses': gamepasses,
        'requested_price': requested_price,
        'matching_gamepass': next((gp for gp in gamepasses if str(gp['id']) == selected_gamepass_id),
                                  None) if selected_gamepass_id else None,
        'instruction': (
            "1. Выберите существующий GamePass или создайте новый с ценой {} Robux.\n"
            "2. Опубликуйте и активируйте 'For Sale'.\n"
            "3. Нажмите 'Проверить', затем 'Подтвердить'.".format(requested_price)
        ),
    }
    return render(request, 'core/withdraw_step3.html', context)


@login_required
@require_POST
def withdraw_confirm(request):
    bonus_balance = float(request.POST.get('bonus_balance', 0))
    place_id = request.POST.get('place_id')
    gamepass_id = request.POST.get('gamepass_id')

    if not gamepass_id:
        return render(request, 'core/withdraw_step3.html', {
            'error': 'Пожалуйста, выберите GamePass.',
            'bonus_balance': bonus_balance,
            'place_id': place_id,
            'gamepasses': get_gamepasses(get_universe_id(place_id))
        })

    withdrawal = Withdrawal.objects.create(
        user=request.user,
        amount=bonus_balance,
        gamepass_id=gamepass_id,
        status='pending'
    )

    request.user.bonus_balance -= bonus_balance
    request.user.save()

    return render(request, 'core/withdraw_confirm.html', {
        'bonus_balance': bonus_balance,
        'place_id': place_id,
        'gamepass_id': gamepass_id,
        'withdrawal_id': withdrawal.id,
        'status': 'success',
        'message': 'Заявка на вывод создана.',
    })


@login_required
@require_POST
def social_bonus(request, social):
    last_bonus_time = request.session.get(f'last_social_bonus_{social}', timezone.now() - timezone.timedelta(hours=1))
    if (timezone.now() - last_bonus_time).total_seconds() < 5:
        return JsonResponse({'success': False, 'message': 'Подождите 5 секунд.'})
    request.user.bonus_balance += 5
    request.user.save()
    request.session[f'last_social_bonus_{social}'] = timezone.now()
    return JsonResponse({'success': True})


@require_POST
def activate_promo(request):
    if not request.user.is_authenticated:
        return JsonResponse({'error': 'Нужно войти'}, status=403)
    promo_code = request.POST.get('promo_code')
    try:
        friend = CustomUser.objects.get(promo_code=promo_code)
        if friend == request.user:
            return JsonResponse({'error': 'Нельзя использовать свой промокод'}, status=400)
        return JsonResponse({'success': 'Промокод принят! Используйте его при покупке.'})
    except CustomUser.DoesNotExist:
        return JsonResponse({'error': 'Неверный промокод'}, status=400)


def login_view(request):
    if request.method == 'POST':
        form = LoginForm(request.POST)
        if form.is_valid():
            roblox_nick = form.cleaned_data['roblox_nick']
            user_id, avatar_url = get_roblox_user_data(roblox_nick)
            if user_id is None:
                return render(request, 'core/login.html', {'form': form, 'error': 'Неверный ник Roblox.'})
            user, created = CustomUser.objects.get_or_create(
                roblox_user_id=user_id,
                defaults={'roblox_nick': roblox_nick}
            )
            if created and not user.promo_code:
                user.promo_code = CustomUser.objects.generate_promo_code()
                user.save()
            if avatar_url and (created or not user.avatar_url):
                user.avatar_url = avatar_url
                user.save()
            login(request, user)
            return redirect('/')
        return render(request, 'core/login.html', {'form': form, 'error': 'Неверный ник Roblox.'})
    else:
        form = LoginForm()
    return render(request, 'core/login.html', {'form': form})


def logout_view(request):
    logout(request)
    return redirect('/')


def get_roblox_user_data(nick):
    try:
        r = requests.post(
            "https://users.roblox.com/v1/usernames/users",
            json={"usernames": [nick], "excludeBannedUsers": True},
            timeout=5
        )
        r.raise_for_status()
        user_data = r.json().get('data', [])
        if not user_data:
            return None, None
        user_data = user_data[0]
        user_id = user_data['id']
        headshot = requests.get(
            f"https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds={user_id}&size=150x150&format=Png"
        )
        headshot.raise_for_status()
        avatar_url = headshot.json()['data'][0]['imageUrl']
        return user_id, avatar_url
    except Exception:
        return None, None


def get_roblox_places(nick):
    try:
        user_id, _ = get_roblox_user_data(nick)
        if not user_id:
            return []
        headers = {'x-api-key': settings.ROBLOX_API_KEY}
        url = f"https://games.roblox.com/v2/users/{user_id}/games"
        params = {"sortOrder": "Asc", "limit": 50}
        places = requests.get(url, headers=headers, params=params, timeout=5)
        places.raise_for_status()
        games = places.json().get('data', [])
        if not games:
            return []
        result = []
        for game in games:
            place_id = str(game.get('rootPlace', {}).get('id'))
            if not place_id:
                continue
            result.append({
                'rootPlace': {
                    'id': place_id,
                    'name': game.get('name', 'Без названия')
                }
            })
        return result
    except Exception:
        return []


def get_universe_id(place_id):
    try:
        r = requests.get(f"https://apis.roblox.com/universes/v1/places/{place_id}/universe")
        r.raise_for_status()
        return r.json().get("universeId")
    except Exception:
        return None


def get_gamepasses(universe_id):
    try:
        r = requests.get(f"https://games.roblox.com/v1/games/{universe_id}/game-passes?limit=100")
        r.raise_for_status()
        data = r.json().get('data', [])
        if not data:
            return []
        return [{'id': gp['id'], 'price': gp['price'], 'name': gp.get('name', f'GamePass {gp["id"]}')} for gp in data]
    except Exception:
        return []
